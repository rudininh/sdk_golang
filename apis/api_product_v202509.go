/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"

    "tiktokshop/open/sdk_golang/models/product/v202509"
)


// ProductV202509APIService ProductV202509API service
type ProductV202509APIService service

type ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest struct {
    ctx context.Context
    ApiService *ProductV202509APIService
    globalProductId string
    xTtsAccessToken *string
    contentType *string
    product202509PartialEditGlobalProductRequestBody *product_v202509.Product202509PartialEditGlobalProductRequestBody
}

// 
func (r ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest) ContentType(contentType string) ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest {
    r.contentType = &contentType
    return r
}
func (r ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest) Product202509PartialEditGlobalProductRequestBody(product202509PartialEditGlobalProductRequestBody product_v202509.Product202509PartialEditGlobalProductRequestBody) ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest {
    r.product202509PartialEditGlobalProductRequestBody = &product202509PartialEditGlobalProductRequestBody
    return r
}
func (r ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest) Execute() (*product_v202509.Product202509PartialEditGlobalProductResponse, *http.Response, error) {
    return r.ApiService.Product202509GlobalProductsGlobalProductIdPartialEditPutExecute(r)
}

/*
Product202509GlobalProductsGlobalProductIdPartialEditPut PartialEditGlobalProduct
Description of [POST]/product/:version/Partial_Edit_Global_Product

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param globalProductId The global product ID generated by TikTok Shop.
@return ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest
*/
func (a *ProductV202509APIService) Product202509GlobalProductsGlobalProductIdPartialEditPut(ctx context.Context, globalProductId string) ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest {
    return ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest{
        ApiService: a,
        ctx: ctx,
        globalProductId: globalProductId,
    }
}

// Execute executes the request
//  @return Product202509PartialEditGlobalProductResponse
func (a *ProductV202509APIService) Product202509GlobalProductsGlobalProductIdPartialEditPutExecute(r ApiProduct202509GlobalProductsGlobalProductIdPartialEditPutRequest) (*product_v202509.Product202509PartialEditGlobalProductResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPut
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202509.Product202509PartialEditGlobalProductResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202509APIService.Product202509GlobalProductsGlobalProductIdPartialEditPut")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202509/global_products/{global_product_id}/partial_edit"
    localVarPath = strings.Replace(localVarPath, "{"+"global_product_id"+"}", url.PathEscape(parameterValueToString(r.globalProductId, "globalProductId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.product202509PartialEditGlobalProductRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProduct202509ProductsProductIdPartialEditPostRequest struct {
    ctx context.Context
    ApiService *ProductV202509APIService
    productId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    product202509PartialEditProductRequestBody *product_v202509.Product202509PartialEditProductRequestBody
}

// 
func (r ApiProduct202509ProductsProductIdPartialEditPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202509ProductsProductIdPartialEditPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202509ProductsProductIdPartialEditPostRequest) ContentType(contentType string) ApiProduct202509ProductsProductIdPartialEditPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiProduct202509ProductsProductIdPartialEditPostRequest) ShopCipher(shopCipher string) ApiProduct202509ProductsProductIdPartialEditPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiProduct202509ProductsProductIdPartialEditPostRequest) Product202509PartialEditProductRequestBody(product202509PartialEditProductRequestBody product_v202509.Product202509PartialEditProductRequestBody) ApiProduct202509ProductsProductIdPartialEditPostRequest {
    r.product202509PartialEditProductRequestBody = &product202509PartialEditProductRequestBody
    return r
}
func (r ApiProduct202509ProductsProductIdPartialEditPostRequest) Execute() (*product_v202509.Product202509PartialEditProductResponse, *http.Response, error) {
    return r.ApiService.Product202509ProductsProductIdPartialEditPostExecute(r)
}

/*
Product202509ProductsProductIdPartialEditPost PartialEditProduct
Edit some properties (e.g. description, images, attributes) of a product that is not in the `FREEZE` or `DELETED` state.
After editing the product, the latest product content (referred to as v2) will be resent for audit review. If the audit passes, v2 is published to the shop, otherwise, the existing product stays live and remains unchanged (keeping v1). However, edits to the `price` or `inventory` fields do not require a reaudit and will be immediately published on the platform. Use the [Product status change](650956aff1fd3102b90b6261) webhook to keep track of the review status.
**Note**: 
- This API is applicable for all sellers.
- There may be a limit to the number of products you can relist per day. We recommend prioritizing key products first to ensure they get published. You can find your listing limit on the Seller Center homepage.
- If a draft or audit-review version exists, unedited fields will retain their values over those of the base (live) version.
- **Updates are handled per top-level property**, so all non-empty fields within an updated object must be supplied to prevent overwriting with blanks. For top-level properties (e.g. `description`, `brand_id`) that are not nested in an object, you can update them individually. Omitting these properties in the request will leave them unchanged. If you need to edit any nested property within an object, you must provide values for all nested properties of that object. Any omitted nested properties will be overwritten with blanks.
- If new mandatory product attributes were added by TikTok Shop after the creation of your product, ensure that you provide these attributes too.
**For global sellers**:
If you're using the local replication listing method, note the following sync rules:
**Sales attribute changes** (in sales attribute id/name) must be synced to other markets. Therefore, you must provide the `seller_sku` and complete `replicated_products` data. The API call will fail if you don't provide these details.
**New SKUs* (new sales attribute value id/name) are optional to sync to other markets. To sync, please provide the `seller_sku` and complete `replicated_products` data.
**General changes** are optional to sync to other markets. To sync, you only need to provide `replicated_products.region`.
**For Tokopedia sellers**:
Note that a product can have **only one active version** across all platforms at any time. If a product is live on both platforms, audit results for the latest version are handled as follows:
- **Mixed audit results**: If the product passes audit on one platform but fails on another, on the successful platform, the product will stay live and be updated with content from the latest version (v2), while on the failed platform, the product will be deactivated and hidden entirely.
- **Audit failure on all platforms**: If the product fails audit on all platforms, the existing product stays live and remains unchanged (keeping v1).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param productId The product ID in TikTok Shop.
@return ApiProduct202509ProductsProductIdPartialEditPostRequest
*/
func (a *ProductV202509APIService) Product202509ProductsProductIdPartialEditPost(ctx context.Context, productId string) ApiProduct202509ProductsProductIdPartialEditPostRequest {
    return ApiProduct202509ProductsProductIdPartialEditPostRequest{
        ApiService: a,
        ctx: ctx,
        productId: productId,
    }
}

// Execute executes the request
//  @return Product202509PartialEditProductResponse
func (a *ProductV202509APIService) Product202509ProductsProductIdPartialEditPostExecute(r ApiProduct202509ProductsProductIdPartialEditPostRequest) (*product_v202509.Product202509PartialEditProductResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202509.Product202509PartialEditProductResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202509APIService.Product202509ProductsProductIdPartialEditPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202509/products/{product_id}/partial_edit"
    localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.product202509PartialEditProductRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProduct202509ProductsProductIdPutRequest struct {
    ctx context.Context
    ApiService *ProductV202509APIService
    productId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    product202509EditProductRequestBody *product_v202509.Product202509EditProductRequestBody
}

// 
func (r ApiProduct202509ProductsProductIdPutRequest) XTtsAccessToken(xTtsAccessToken string) ApiProduct202509ProductsProductIdPutRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiProduct202509ProductsProductIdPutRequest) ContentType(contentType string) ApiProduct202509ProductsProductIdPutRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiProduct202509ProductsProductIdPutRequest) ShopCipher(shopCipher string) ApiProduct202509ProductsProductIdPutRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiProduct202509ProductsProductIdPutRequest) Product202509EditProductRequestBody(product202509EditProductRequestBody product_v202509.Product202509EditProductRequestBody) ApiProduct202509ProductsProductIdPutRequest {
    r.product202509EditProductRequestBody = &product202509EditProductRequestBody
    return r
}
func (r ApiProduct202509ProductsProductIdPutRequest) Execute() (*product_v202509.Product202509EditProductResponse, *http.Response, error) {
    return r.ApiService.Product202509ProductsProductIdPutExecute(r)
}

/*
Product202509ProductsProductIdPut EditProduct
Edit all properties (e.g. description, brand, images) of an existing product that is not in the `FREEZE` or `DELETED` state.
After editing the product, the latest product content (referred to as v2) will be resent for audit review. If the audit passes, v2 is published to the shop, otherwise, the existing product stays live and remains unchanged (keeping v1). However, edits to the `price` or `inventory` fields do not require a reaudit and will be immediately published on the platform. Use the [Product status change](https://partner.tiktokshop.com/docv2/page/650956aff1fd3102b90b6261) webhook to keep track of the review status.
**Note**: 
- This API is applicable only for **active sellers/shops** that have completed the KYC onboarding process.
- There may be a limit to the number of products you can relist per day. We recommend prioritizing key products first to ensure they get published. You can find your listing limit on the Seller Center homepage.
- All inputs, including blanks, in the request payload will overwrite existing values. To retain an existing value, make sure to include it in your request. Exceptions to this rule are the `price` and `inventory` fields, which will remain unchanged if they are omitted from the request. Therefore, **it is strongly recommended to retrieve the latest product data using [Get Product](6509d85b4a0bb702c057fdda) and submit the complete data when editing**. This ensures accuracy and helps avoid errors or unintentional data loss due to missing fields.
- If you wish to edit only certain properties, you can use the [Partial Edit Product API](650a98d74a0bb702c06c3289), [Update Inventory API](6503068fc20ad60284b38858), or the [Update Price API](650307de5a12ff0294eac8b0).
- The language used in the product content must align with the target market's language (e.g. don't use Chinese), otherwise the listing will fail or be rejected.
**For global sellers**:
If you're using the local replication listing method, note the following sync rules:
- To sync any changes to other markets, please provide the `seller_sku` and complete `replicated_products` data. 
- Note that **category changes** and **sales attribute changes** (in sales attribute id/name) must be synced to other markets. The API call will fail if you don't provide these details.
**For Tokopedia sellers**:
Note that a product can have **only one active version** across all platforms at any time. If a product is live on both platforms, audit results for the latest version are handled as follows:
- **Mixed audit results**: If the product passes audit on one platform but fails on another, on the successful platform, the product will stay live and be updated with content from the latest version (v2), while on the failed platform, the product will be deactivated and hidden entirely.
- **Audit failure on all platforms**: If the product fails audit on all platforms, the existing product stays live and remains unchanged (keeping v1).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param productId The product ID generated by TikTok Shop.
@return ApiProduct202509ProductsProductIdPutRequest
*/
func (a *ProductV202509APIService) Product202509ProductsProductIdPut(ctx context.Context, productId string) ApiProduct202509ProductsProductIdPutRequest {
    return ApiProduct202509ProductsProductIdPutRequest{
        ApiService: a,
        ctx: ctx,
        productId: productId,
    }
}

// Execute executes the request
//  @return Product202509EditProductResponse
func (a *ProductV202509APIService) Product202509ProductsProductIdPutExecute(r ApiProduct202509ProductsProductIdPutRequest) (*product_v202509.Product202509EditProductResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPut
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *product_v202509.Product202509EditProductResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductV202509APIService.Product202509ProductsProductIdPut")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/product/202509/products/{product_id}"
    localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.product202509EditProductRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
