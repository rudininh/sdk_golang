/*
tiktok shop openapi

sdk for apis

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apis

import (
    "bytes"
    "context"
    "io"
    "net/http"
    "net/url"
    "strings"
    "os"

    "tiktokshop/open/sdk_golang/models/customer_service/v202309"
)


// CustomerServiceV202309APIService CustomerServiceV202309API service
type CustomerServiceV202309APIService service

type ApiCustomerService202309AgentsSettingsGetRequest struct {
    ctx context.Context
    ApiService *CustomerServiceV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiCustomerService202309AgentsSettingsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiCustomerService202309AgentsSettingsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiCustomerService202309AgentsSettingsGetRequest) ContentType(contentType string) ApiCustomerService202309AgentsSettingsGetRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiCustomerService202309AgentsSettingsGetRequest) ShopCipher(shopCipher string) ApiCustomerService202309AgentsSettingsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiCustomerService202309AgentsSettingsGetRequest) Execute() (*customer_service_v202309.CustomerService202309GetAgentSettingsResponse, *http.Response, error) {
    return r.ApiService.CustomerService202309AgentsSettingsGetExecute(r)
}

/*
CustomerService202309AgentsSettingsGet GetAgentSettings
This API is used to get agent settings. This API allows the agent to see whether the agent can accept chats from buyers. This API is a read-only endpoint. There will be no side effects, and can be retried safely. Note:  1. The current API version can only get settings on behalf of the shop, or the owner account holder on Seller Center. The owner in this case is acting as the customer service agent. In the future, we plan to make this API available to subaccount holders (who has customer service role) in Seller Center.  2. This API is to allow the agent to get his/her own setting.  See more information in API overview 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiCustomerService202309AgentsSettingsGetRequest
*/
func (a *CustomerServiceV202309APIService) CustomerService202309AgentsSettingsGet(ctx context.Context) ApiCustomerService202309AgentsSettingsGetRequest {
    return ApiCustomerService202309AgentsSettingsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return CustomerService202309GetAgentSettingsResponse
func (a *CustomerServiceV202309APIService) CustomerService202309AgentsSettingsGetExecute(r ApiCustomerService202309AgentsSettingsGetRequest) (*customer_service_v202309.CustomerService202309GetAgentSettingsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *customer_service_v202309.CustomerService202309GetAgentSettingsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerServiceV202309APIService.CustomerService202309AgentsSettingsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/customer_service/202309/agents/settings"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomerService202309AgentsSettingsPutRequest struct {
    ctx context.Context
    ApiService *CustomerServiceV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    customerService202309UpdateAgentSettingsRequestBody *customer_service_v202309.CustomerService202309UpdateAgentSettingsRequestBody
}

// 
func (r ApiCustomerService202309AgentsSettingsPutRequest) XTtsAccessToken(xTtsAccessToken string) ApiCustomerService202309AgentsSettingsPutRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiCustomerService202309AgentsSettingsPutRequest) ContentType(contentType string) ApiCustomerService202309AgentsSettingsPutRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiCustomerService202309AgentsSettingsPutRequest) ShopCipher(shopCipher string) ApiCustomerService202309AgentsSettingsPutRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiCustomerService202309AgentsSettingsPutRequest) CustomerService202309UpdateAgentSettingsRequestBody(customerService202309UpdateAgentSettingsRequestBody customer_service_v202309.CustomerService202309UpdateAgentSettingsRequestBody) ApiCustomerService202309AgentsSettingsPutRequest {
    r.customerService202309UpdateAgentSettingsRequestBody = &customerService202309UpdateAgentSettingsRequestBody
    return r
}
func (r ApiCustomerService202309AgentsSettingsPutRequest) Execute() (*customer_service_v202309.CustomerService202309UpdateAgentSettingsResponse, *http.Response, error) {
    return r.ApiService.CustomerService202309AgentsSettingsPutExecute(r)
}

/*
CustomerService202309AgentsSettingsPut UpdateAgentSettings
Use this API to update agent status on behalf of the agent. Agents can set whether they can accept auto assigned chats. Before using API, we recommend setting can_accept_chat to true, in order to accept chats.  Note:  1. The current API version can only update settings on behalf of the shop, or the owner account holder on Seller Center. The owner in this case is acting as the customer service agent. In the future, we plan to make this API available to subaccount holders (who has customer service role) in Seller Center.  2. This API is to allow the agent to update their own setting.  See more information in API overview 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiCustomerService202309AgentsSettingsPutRequest
*/
func (a *CustomerServiceV202309APIService) CustomerService202309AgentsSettingsPut(ctx context.Context) ApiCustomerService202309AgentsSettingsPutRequest {
    return ApiCustomerService202309AgentsSettingsPutRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return CustomerService202309UpdateAgentSettingsResponse
func (a *CustomerServiceV202309APIService) CustomerService202309AgentsSettingsPutExecute(r ApiCustomerService202309AgentsSettingsPutRequest) (*customer_service_v202309.CustomerService202309UpdateAgentSettingsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPut
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *customer_service_v202309.CustomerService202309UpdateAgentSettingsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerServiceV202309APIService.CustomerService202309AgentsSettingsPut")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/customer_service/202309/agents/settings"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.customerService202309UpdateAgentSettingsRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomerService202309ConversationsConversationIdMessagesGetRequest struct {
    ctx context.Context
    ApiService *CustomerServiceV202309APIService
    conversationId string
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    locale *string
    sortOrder *string
    sortField *string
    shopCipher *string
}

// Number of conversations in one page  Max 10.
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) PageSize(pageSize int32) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) ContentType(contentType string) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    r.contentType = &contentType
    return r
}
// Paging cursor, this means where this query should start. For the next page, use \&quot;next_page_token\&quot; in response.
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) PageToken(pageToken string) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    r.pageToken = &pageToken
    return r
}
// System message&#39;s display language. The messages sent by System will be returned in the setting language; The messages sent by the buyer, the shop, the CS agent will not be affected. The default value is en (English).  Possible enumerations: - de-DE (German, Germany) - en (English) - en-GB (English, United Kingdom) - es-ES (Spanish, Spain) - es-MX (Spanish, Latin America) - fr-FR (French, France) - id-ID (Indonesian, Indonesia) - it-IT (Italian, Italy) - ja-JP (Japanese) - ms-MY (Malay, Malaysia) - th-TH (Thai, Thailand) - vi-VN (Vietnamese, Vietnam) - pt-BR (Portuguese, Brazil) - zh-CN (Simplified Chinese, China)
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) Locale(locale string) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    r.locale = &locale
    return r
}
// Sort order. Possible enumerations: - DESC(default) - ASC
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) SortOrder(sortOrder string) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    r.sortOrder = &sortOrder
    return r
}
// Sort messages by one of the following properties: - &#x60;create_time&#x60; (default) - &#x60;index&#x60;
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) SortField(sortField string) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    r.sortField = &sortField
    return r
}
// 
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) ShopCipher(shopCipher string) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) Execute() (*customer_service_v202309.CustomerService202309GetConversationMessagesResponse, *http.Response, error) {
    return r.ApiService.CustomerService202309ConversationsConversationIdMessagesGetExecute(r)
}

/*
CustomerService202309ConversationsConversationIdMessagesGet GetConversationMessages
Use this API to get all messages in a conversation between a buyer and a shop. 
Calling this API does not mark the messages as read. You are suggested to call [Read Message](650a59f7c16ffe02b8e8db3f) to mark the messages read.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param conversationId Conversation ID
@return ApiCustomerService202309ConversationsConversationIdMessagesGetRequest
*/
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsConversationIdMessagesGet(ctx context.Context, conversationId string) ApiCustomerService202309ConversationsConversationIdMessagesGetRequest {
    return ApiCustomerService202309ConversationsConversationIdMessagesGetRequest{
        ApiService: a,
        ctx: ctx,
        conversationId: conversationId,
    }
}

// Execute executes the request
//  @return CustomerService202309GetConversationMessagesResponse
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsConversationIdMessagesGetExecute(r ApiCustomerService202309ConversationsConversationIdMessagesGetRequest) (*customer_service_v202309.CustomerService202309GetConversationMessagesResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *customer_service_v202309.CustomerService202309GetConversationMessagesResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerServiceV202309APIService.CustomerService202309ConversationsConversationIdMessagesGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/customer_service/202309/conversations/{conversation_id}/messages"
    localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.locale != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
    }
    if r.sortOrder != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
    }
    if r.sortField != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomerService202309ConversationsConversationIdMessagesPostRequest struct {
    ctx context.Context
    ApiService *CustomerServiceV202309APIService
    conversationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    customerService202309SendMessageRequestBody *customer_service_v202309.CustomerService202309SendMessageRequestBody
}

// 
func (r ApiCustomerService202309ConversationsConversationIdMessagesPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiCustomerService202309ConversationsConversationIdMessagesPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiCustomerService202309ConversationsConversationIdMessagesPostRequest) ContentType(contentType string) ApiCustomerService202309ConversationsConversationIdMessagesPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiCustomerService202309ConversationsConversationIdMessagesPostRequest) ShopCipher(shopCipher string) ApiCustomerService202309ConversationsConversationIdMessagesPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiCustomerService202309ConversationsConversationIdMessagesPostRequest) CustomerService202309SendMessageRequestBody(customerService202309SendMessageRequestBody customer_service_v202309.CustomerService202309SendMessageRequestBody) ApiCustomerService202309ConversationsConversationIdMessagesPostRequest {
    r.customerService202309SendMessageRequestBody = &customerService202309SendMessageRequestBody
    return r
}
func (r ApiCustomerService202309ConversationsConversationIdMessagesPostRequest) Execute() (*customer_service_v202309.CustomerService202309SendMessageResponse, *http.Response, error) {
    return r.ApiService.CustomerService202309ConversationsConversationIdMessagesPostExecute(r)
}

/*
CustomerService202309ConversationsConversationIdMessagesPost SendMessage
Use this API to send a message to the buyer in a conversation.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param conversationId Conversation ID
@return ApiCustomerService202309ConversationsConversationIdMessagesPostRequest
*/
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsConversationIdMessagesPost(ctx context.Context, conversationId string) ApiCustomerService202309ConversationsConversationIdMessagesPostRequest {
    return ApiCustomerService202309ConversationsConversationIdMessagesPostRequest{
        ApiService: a,
        ctx: ctx,
        conversationId: conversationId,
    }
}

// Execute executes the request
//  @return CustomerService202309SendMessageResponse
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsConversationIdMessagesPostExecute(r ApiCustomerService202309ConversationsConversationIdMessagesPostRequest) (*customer_service_v202309.CustomerService202309SendMessageResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *customer_service_v202309.CustomerService202309SendMessageResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerServiceV202309APIService.CustomerService202309ConversationsConversationIdMessagesPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/customer_service/202309/conversations/{conversation_id}/messages"
    localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.customerService202309SendMessageRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest struct {
    ctx context.Context
    ApiService *CustomerServiceV202309APIService
    conversationId string
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
}

// 
func (r ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest) ContentType(contentType string) ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest) ShopCipher(shopCipher string) ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest) Execute() (*customer_service_v202309.CustomerService202309ReadMessageResponse, *http.Response, error) {
    return r.ApiService.CustomerService202309ConversationsConversationIdMessagesReadPostExecute(r)
}

/*
CustomerService202309ConversationsConversationIdMessagesReadPost ReadMessage
Use this API to mark all messages sent by the buyer as read. You are suggested to call this API before replying to their messages.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@param conversationId 
@return ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest
*/
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsConversationIdMessagesReadPost(ctx context.Context, conversationId string) ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest {
    return ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest{
        ApiService: a,
        ctx: ctx,
        conversationId: conversationId,
    }
}

// Execute executes the request
//  @return CustomerService202309ReadMessageResponse
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsConversationIdMessagesReadPostExecute(r ApiCustomerService202309ConversationsConversationIdMessagesReadPostRequest) (*customer_service_v202309.CustomerService202309ReadMessageResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *customer_service_v202309.CustomerService202309ReadMessageResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerServiceV202309APIService.CustomerService202309ConversationsConversationIdMessagesReadPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/customer_service/202309/conversations/{conversation_id}/messages/read"
    localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomerService202309ConversationsGetRequest struct {
    ctx context.Context
    ApiService *CustomerServiceV202309APIService
    pageSize *int32
    xTtsAccessToken *string
    contentType *string
    pageToken *string
    locale *string
    shopCipher *string
}

// Number of conversations on one page  Max 20. 
func (r ApiCustomerService202309ConversationsGetRequest) PageSize(pageSize int32) ApiCustomerService202309ConversationsGetRequest {
    r.pageSize = &pageSize
    return r
}
// 
func (r ApiCustomerService202309ConversationsGetRequest) XTtsAccessToken(xTtsAccessToken string) ApiCustomerService202309ConversationsGetRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiCustomerService202309ConversationsGetRequest) ContentType(contentType string) ApiCustomerService202309ConversationsGetRequest {
    r.contentType = &contentType
    return r
}
// Paging cursor, this means where this query should start. For the next page, use \&quot;next_page_token\&quot; in response.
func (r ApiCustomerService202309ConversationsGetRequest) PageToken(pageToken string) ApiCustomerService202309ConversationsGetRequest {
    r.pageToken = &pageToken
    return r
}
// System message&#39;s display language. The messages sent by System will be returned in the setting language; The messages sent by the buyer, the shop, the CS agent will not be affected. The default value is en (English).  Possible enumerations: - de-DE (German, Germany) - en (English) - en-GB (English, United Kingdom) - es-ES (Spanish, Spain) - es-MX (Spanish, Latin America) - fr-FR (French, France) - id-ID (Indonesian, Indonesia) - it-IT (Italian, Italy) - ja-JP (Japanese) - ms-MY (Malay, Malaysia) - th-TH (Thai, Thailand) - vi-VN (Vietnamese, Vietnam) - pt-BR (Portuguese, Brazil) - zh-CN (Simplified Chinese, China)
func (r ApiCustomerService202309ConversationsGetRequest) Locale(locale string) ApiCustomerService202309ConversationsGetRequest {
    r.locale = &locale
    return r
}
// 
func (r ApiCustomerService202309ConversationsGetRequest) ShopCipher(shopCipher string) ApiCustomerService202309ConversationsGetRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiCustomerService202309ConversationsGetRequest) Execute() (*customer_service_v202309.CustomerService202309GetConversationsResponse, *http.Response, error) {
    return r.ApiService.CustomerService202309ConversationsGetExecute(r)
}

/*
CustomerService202309ConversationsGet GetConversations
Use this API to retrieve a shop's conversations with buyers. 

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiCustomerService202309ConversationsGetRequest
*/
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsGet(ctx context.Context) ApiCustomerService202309ConversationsGetRequest {
    return ApiCustomerService202309ConversationsGetRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return CustomerService202309GetConversationsResponse
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsGetExecute(r ApiCustomerService202309ConversationsGetRequest) (*customer_service_v202309.CustomerService202309GetConversationsResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodGet
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *customer_service_v202309.CustomerService202309GetConversationsResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerServiceV202309APIService.CustomerService202309ConversationsGet")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/customer_service/202309/conversations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.pageSize == nil {
        return localVarReturnValue, nil, reportError("pageSize is required and must be specified")
    }
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.pageToken != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_token", r.pageToken, "")
    }
    parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
    if r.locale != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
    }
    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomerService202309ConversationsPostRequest struct {
    ctx context.Context
    ApiService *CustomerServiceV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    customerService202309CreateConversationRequestBody *customer_service_v202309.CustomerService202309CreateConversationRequestBody
}

// 
func (r ApiCustomerService202309ConversationsPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiCustomerService202309ConversationsPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: application/json
func (r ApiCustomerService202309ConversationsPostRequest) ContentType(contentType string) ApiCustomerService202309ConversationsPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiCustomerService202309ConversationsPostRequest) ShopCipher(shopCipher string) ApiCustomerService202309ConversationsPostRequest {
    r.shopCipher = &shopCipher
    return r
}
func (r ApiCustomerService202309ConversationsPostRequest) CustomerService202309CreateConversationRequestBody(customerService202309CreateConversationRequestBody customer_service_v202309.CustomerService202309CreateConversationRequestBody) ApiCustomerService202309ConversationsPostRequest {
    r.customerService202309CreateConversationRequestBody = &customerService202309CreateConversationRequestBody
    return r
}
func (r ApiCustomerService202309ConversationsPostRequest) Execute() (*customer_service_v202309.CustomerService202309CreateConversationResponse, *http.Response, error) {
    return r.ApiService.CustomerService202309ConversationsPostExecute(r)
}

/*
CustomerService202309ConversationsPost CreateConversation
Use this API to create a conversation with the specified buyer, on behalf of a shop. When there's no prior conversation, calling this API creates a new conversation; when there's a prior conversation, no matter whether it's active, finished, or closed, calling this API reopens the conversation and returns the same conversation ID as the prior one.

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiCustomerService202309ConversationsPostRequest
*/
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsPost(ctx context.Context) ApiCustomerService202309ConversationsPostRequest {
    return ApiCustomerService202309ConversationsPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return CustomerService202309CreateConversationResponse
func (a *CustomerServiceV202309APIService) CustomerService202309ConversationsPostExecute(r ApiCustomerService202309ConversationsPostRequest) (*customer_service_v202309.CustomerService202309CreateConversationResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *customer_service_v202309.CustomerService202309CreateConversationResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerServiceV202309APIService.CustomerService202309ConversationsPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/customer_service/202309/conversations"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"application/json"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    // body params
    localVarPostBody = r.customerService202309CreateConversationRequestBody
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCustomerService202309ImagesUploadPostRequest struct {
    ctx context.Context
    ApiService *CustomerServiceV202309APIService
    xTtsAccessToken *string
    contentType *string
    shopCipher *string
    data *os.File
}

// 
func (r ApiCustomerService202309ImagesUploadPostRequest) XTtsAccessToken(xTtsAccessToken string) ApiCustomerService202309ImagesUploadPostRequest {
    r.xTtsAccessToken = &xTtsAccessToken
    return r
}
// Allowed type: multipart/form-data
func (r ApiCustomerService202309ImagesUploadPostRequest) ContentType(contentType string) ApiCustomerService202309ImagesUploadPostRequest {
    r.contentType = &contentType
    return r
}
// 
func (r ApiCustomerService202309ImagesUploadPostRequest) ShopCipher(shopCipher string) ApiCustomerService202309ImagesUploadPostRequest {
    r.shopCipher = &shopCipher
    return r
}
// The format of the image must be jpg, gif, webp, or png. The size of the image must not exceed 10MB.
func (r ApiCustomerService202309ImagesUploadPostRequest) Data(data *os.File) ApiCustomerService202309ImagesUploadPostRequest {
    r.data = data
    return r
}
func (r ApiCustomerService202309ImagesUploadPostRequest) Execute() (*customer_service_v202309.CustomerService202309UploadBuyerMessagesImageResponse, *http.Response, error) {
    return r.ApiService.CustomerService202309ImagesUploadPostExecute(r)
}

/*
CustomerService202309ImagesUploadPost UploadBuyerMessagesImage
You must use this API to upload the image first, before sending an image as a message using [Send Message](650a58bbbace3e02b7556286).

@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return ApiCustomerService202309ImagesUploadPostRequest
*/
func (a *CustomerServiceV202309APIService) CustomerService202309ImagesUploadPost(ctx context.Context) ApiCustomerService202309ImagesUploadPostRequest {
    return ApiCustomerService202309ImagesUploadPostRequest{
        ApiService: a,
        ctx: ctx,
    }
}

// Execute executes the request
//  @return CustomerService202309UploadBuyerMessagesImageResponse
func (a *CustomerServiceV202309APIService) CustomerService202309ImagesUploadPostExecute(r ApiCustomerService202309ImagesUploadPostRequest) (*customer_service_v202309.CustomerService202309UploadBuyerMessagesImageResponse, *http.Response, error) {
    var (
        localVarHTTPMethod   = http.MethodPost
        localVarPostBody     interface{}
        formFiles            []formFile
        localVarReturnValue  *customer_service_v202309.CustomerService202309UploadBuyerMessagesImageResponse
    )

    localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerServiceV202309APIService.CustomerService202309ImagesUploadPost")
    if err != nil {
        return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
    }

    localVarPath := localBasePath + "/customer_service/202309/images/upload"

    localVarHeaderParams := make(map[string]string)
    localVarQueryParams := url.Values{}
    localVarFormParams := url.Values{}
    if r.xTtsAccessToken == nil {
        return localVarReturnValue, nil, reportError("xTtsAccessToken is required and must be specified")
    }
    if r.contentType == nil {
        return localVarReturnValue, nil, reportError("contentType is required and must be specified")
    }

    if r.shopCipher != nil {
    parameterAddToHeaderOrQuery(localVarQueryParams, "shop_cipher", r.shopCipher, "")
    }
    // to determine the Content-Type header
    localVarHTTPContentTypes := []string{"multipart/form-data"}

    // set Content-Type header
    localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
    if localVarHTTPContentType != "" {
        localVarHeaderParams["Content-Type"] = localVarHTTPContentType
    }

    // to determine the Accept header
    localVarHTTPHeaderAccepts := []string{"application/json"}

    // set Accept header
    localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
    if localVarHTTPHeaderAccept != "" {
        localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
    }
    parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tts-access-token", r.xTtsAccessToken, "")
    parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "")
    var dataLocalVarFormFileName string
    var dataLocalVarFileName     string
    var dataLocalVarFileBytes    []byte

    dataLocalVarFormFileName = "data"
    dataLocalVarFile := r.data

    if dataLocalVarFile != nil {
        fbs, _ := io.ReadAll(dataLocalVarFile)

        dataLocalVarFileBytes = fbs
        dataLocalVarFileName = dataLocalVarFile.Name()
        dataLocalVarFile.Close()
        formFiles = append(formFiles, formFile{fileBytes: dataLocalVarFileBytes, fileName: dataLocalVarFileName, formFileName: dataLocalVarFormFileName})
    }
    req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
    if err != nil {
        return localVarReturnValue, nil, err
    }

    localVarHTTPResponse, err := a.client.callAPI(req)
    if err != nil || localVarHTTPResponse == nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
    localVarHTTPResponse.Body.Close()
    localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
    if err != nil {
        return localVarReturnValue, localVarHTTPResponse, err
    }

    if localVarHTTPResponse.StatusCode >= 300 {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: localVarHTTPResponse.Status,
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
        newErr := &GenericOpenAPIError{
            body:  localVarBody,
            error: err.Error(),
        }
        return localVarReturnValue, localVarHTTPResponse, newErr
    }

    return localVarReturnValue, localVarHTTPResponse, nil
}
